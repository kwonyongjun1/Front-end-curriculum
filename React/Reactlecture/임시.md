### 1. map 함수


### 2. filter 함수

### 3. ReactState

리액트에서 데이터가 변할 때 화면을 다시 렌더링 해주기 위해서는 React State를 사용한다.

React State는 컴포넌트의 렌더링 결과물에 영향을 주는 데이터를 갖고 있는 객체이며 (State가 변경되면 컴포넌트는 리랜더링(Re-rendering)됩니다.

또한 State는 컴포넌트 안에서 관리된다.

### 4. 전개 연산자

전개 연산자는 ECMAScript6(2015)에서 새롭게 추가되었으며, 특정 객체 또는 배열의 값을 다른 객체, 배열로 복제하거나 옮길 때 사용되며 

모양은 ... 이다.

#### 배열

![image](https://user-images.githubusercontent.com/70560755/227765244-709f2746-ed3b-401b-b674-a96e246c5a3e.png)


#### 객체

![image](https://user-images.githubusercontent.com/70560755/227765255-46e99e44-0f3d-46f2-ae7e-3340f6f9d7d6.png)


#### 기존 배열을 보존


![image](https://user-images.githubusercontent.com/70560755/227765259-d5cc8947-f75e-448d-ba71-6f5c3a617d35.png)


### 4. 조건부 삼항 연산자

![image](https://user-images.githubusercontent.com/70560755/227766565-adaae879-777f-41ee-8e39-1245792324d5.png)


### 5. React Hooks


React Hooks는 class 없이 state를 사용할 수 있는 새로운 기능이다.

주로 Class Component로 사용되어온 React에서의 문제점을 개선되어 개발되었으며 

기존 React는 Class Component를 사용하고 React Hooks는 Functional Component를 사용한다.


#### React Hooks의 장점

1. useEffect를 이용해 생명주기를 조작하여 코드가 간결해진다.
2. HOC 컴포넌트를 Custom React Hooks로 대체하여 Wrapper 컴포넌트를 줄이게되었다.
3. 더 빠른 성능과 더 나은 가독성을 보여준다.


HOC(Higher Order Component) 란?

컴포넌트를 인자로 받아 새로운 리액트 컴포넌트를 리턴하는 함수이다. 


### State와 Proprs 

#### State

해당 컴포넌트 내부에서 데이터를 전달하려면 State를 사용한다.

State는 변경 가능하며 변경하면 re-render가 된다.

#### Props(Properties)

상속하는 부모 컴포넌트로부터 자녀 컴포넌트에 데이터등을 전달하는 방법으로 Props는 일기 전용으로 자녀 컴포넌트 입장에서는 변하지 않는다.
(변하게 하고자 하면 부모 컴포넌트에서 state를 변경시켜줘야한다.)


### 자바스크립트 타입을 통한 불변성

원시 타입 : Boolean, String, Number, null, undefined, Symbol (불변성을 가지고 있다.) 
참조 타입 : Object, Array 


Javascript는 원시 타입에 대한 참조 및 값을 저장하기 위해 Call Stak 메모리 공간을 사용하지만 참조 타입의 경우 Heap이라는 별도의 메모리 공간을 사용한다.


#### 불변성을 지켜야하는 이유

1. 참조 타입에서 객체나 배열의 값이 변할 때 원본 데이터가 변경되기에 이 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있어서 프로그래밍의 복잡도가 올라간다.

2. 리액트에서 화면을 업데이트할 때 불변성을 지켜서 값을 이전 값과 비교해서 변경된 사항을 확인한 후 업데이트하기 때문에 불변성을 지켜줘야한다.

#### 불변성을 지키는 방법

참조 타입에서는 값을 바꿨을 때 Call Stack 주소 값은  같은데 Heap 메모리 값만 바꿔주기에 불변성을 유지할 수 없었으므로 아예 새로운 배열을 반환하는 메소드를 사용하면된다.

spread operator, map, filter, slice, reduce

원본 데이터를 변경하는 메소드 => splice, push


```javascript
const array = [1,2,3,4];
const sameArray = array;
sameArray.push(5);

console.log(array === sameArray); // true

const array2 = [1,2,3,4];
const differentArray2 = [...array2, 5];

console.log(array2 === differentArray2); // false
```

### React.memo

컴포넌트가 동일한 props로 동일한 결과를 렌더링해낸다면, React.memo를 호출하고 결과를 메모이징(Memoizing)하도록 래핑하여 경우에 따라 성능 향상을 누릴 수 있다. 즉, React는 컴포넌트를 렌더링하지 않고 마지막으로 렌더링된 결과를 재사용한다.


부모 컴포넌트가 렌더링 되면 모든 자식 컴포넌트 또한 렌더링 되는데 props가 변경되지 않았다면 자식 컴포넌트는 렌더링 될 필요가 없다. 이때 React.memo 함수를 사용해 불필요한 렌더링을 방지해 준다.


사용법은 react.memo를 감싸주면된다.

```
// case 1 
const Test = () =>{

}

export default react.memo(Test)

// case 2

const Test = react.memo(() =>{

}
)
export default Test

```

#### 사용하는경우 

1. 함수형 컴포넌트인 경우
2. 컴포넌트가 같은 props로 자주 렌더링 되는 경우
3. 무겁고 복잡한 연산이 있는 경우

#### 사용할 필요가 없는 경우

1. 컴포넌트가 다른 props로 자주 렌더링 되는 경우
2. 가벼운 프로젝트인 경우


### useCallback

특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용된다.


```javascript
const handleClick = useCallback((id) =>{
    let newTodoData = todoData.filter((data) => data.id !== id);
    setTodoData(newTodoData)
  }, [todoData])
```

useCallback 적용은 useCallback 안에 콜백함수와 의존성 배열을 순서대로 넣어주면 된다.


함수 내에서 참조하는 state, props가 있다면 의존성 배열에 추가해주시면 되고 useCallback으로 인해서 todoData가 변하지 않는 다면 함수는 새로 생성되지 않는다. 

새로 생성되지 않기에 메모리에 새로 할당되지 않고 동일 참조 값을 사용하게 되며 의존성 배열에 아무것도 없다면 컴포넌트가 최초 렌더링 시에만 함수가 생성되며 그 이후에는 동일한 참조 값을 사용하는 함수가 된다. 