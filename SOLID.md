### 객체지향 설계과정


1. 요구사항 (제공해야 할 기능) 을 찾고 세분화 한다. 그리고 그 기능을 알맞은 객체로 할당한다.
2. 기능을 구현하는 데에 필요한 데이터를 객체에 추가한다.
3. 해당 데이터를 이용하는 기능을 구현한다. (기능은 최대한 캡슐화)
4. 객체 간에 어떻게 메소드 호출을 주고받을 지 결정한다.


### 객체지향 설계원칙(SOLID 원칙)



#### SRP(Single Responsibility) 단일 책임 원칙

- 클래스는 단 한개의 기능을 가져야 한다.
- 클래스를 변경하는 이유는 단 하나여야한다.
- 이를 지키지 않으면, 한 기능의 변경에 의해 다른 기능과 관련된 코드에 영향을 미칠 수 있다.

#### OCP(Open-Closed) 개방-폐쇄 원칙

- 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야한다.

OCP 는 추상화 (인터페이스) 와 상속 (다형성) 등을 통해 구현해낼 수 있다. 

자주 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 함으로써 유연함을 높이는 것이 핵심이다.


#### LSP(Liskov Substitution) 리스코프 치환 원칙

- 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 한다.

→ 즉, 상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 동작해야 한다.
- 상속관계에서는 꼭 일반화 관계가 성립해야 한다는 의미이다.
- 상속관계가 아닌 클래스들을 상속관계로 설정하면, 이 원칙이 위배된다.

리스코프 치환 원칙을 지키지 않으면 개방 폐쇄 원칙을 위반하게 되는 것이다. 기능 확장을 위해 기존의 코드를 여러 번 수정해야 할 것이다. 따라서 상속 관계를 잘 정의하여 LSP 원칙이 위배되지 않도록 설계해야 한다.

#### ISP(Interface Segregation) 인터페이스 분리 원칙

- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다는 원칙
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.

→ 하나의 통상적인 인터페이스보다는 차라리 여러 개의 세부적인 (구체적인) 인터페이스가 낫다.
- 인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야 한다.

각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 하는 것이 핵심이다.

### DIP(Dependency Inversion) 의존 역전 원칙

- 의존 관계를 맺을 때, 변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 한다.

→ 구체화된 클래스에 의존하기 보다는 추상 클래스나 인터페이스에 의존해야 한다
- 즉, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
- 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
- 저수준 모듈이 변경되어도 고수준 모듈은 변경이 필요없는 형태가 이상적이다.
